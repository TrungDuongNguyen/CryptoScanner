<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Daily Crypto Scanner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #2a1a4a 100%);
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .header h1 {
            font-size: 2.8rem;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            animation: shimmer 3s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(45deg); }
        }

        .subtitle {
            font-size: 1.1rem;
            color: #b0b0b0;
            margin-bottom: 20px;
        }

        .market-baseline {
            display: inline-block;
            background: rgba(69, 183, 209, 0.2);
            padding: 10px 20px;
            border-radius: 25px;
            border: 1px solid rgba(69, 183, 209, 0.3);
            font-weight: 600;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 15px 30px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .control-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
        }

        .scanner-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 30px;
        }

        .opportunity-list {
            background: rgba(255, 255, 255, 0.06);
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .list-header {
            padding: 20px 25px;
            font-size: 1.3rem;
            font-weight: 700;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .active-header {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            color: white;
        }

        .potential-header {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
        }

        .list-count {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.9rem;
        }

        .opportunity-item {
            padding: 20px 25px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
        }

        .opportunity-item:hover {
            background: rgba(255, 255, 255, 0.03);
            transform: translateX(5px);
        }

        .opportunity-item:last-child {
            border-bottom: none;
        }

        .coin-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .coin-name {
            font-size: 1.1rem;
            font-weight: 700;
            color: #ffffff;
        }

        .coin-symbol {
            color: #4ecdc4;
            font-size: 0.9rem;
            margin-left: 8px;
        }

        .signal-badge {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .momentum-confirmed {
            background: rgba(255, 107, 107, 0.2);
            color: #ff6b6b;
            border: 1px solid rgba(255, 107, 107, 0.3);
        }

        .accumulation-phase {
            background: rgba(78, 205, 196, 0.2);
            color: #4ecdc4;
            border: 1px solid rgba(78, 205, 196, 0.3);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 12px;
        }

        .metric {
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .metric-label {
            color: #888;
            margin-right: 5px;
        }

        .metric-value {
            color: #ffffff;
            font-weight: 600;
        }

        .volume-positive {
            color: #4ecdc4;
        }

        .price-positive {
            color: #96ceb4;
        }

        .price-neutral {
            color: #ffd93d;
        }

        .support-info {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
            font-size: 0.85rem;
            margin-top: 10px;
        }

        .risk-timeframe {
            display: flex;
            justify-content: space-between;
            margin-top: 12px;
            font-size: 0.8rem;
        }

        .risk-level {
            padding: 2px 8px;
            border-radius: 8px;
            font-weight: 600;
        }

        .risk-medium-high {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }

        .risk-low-medium {
            background: rgba(40, 167, 69, 0.2);
            color: #28a745;
        }

        .loading {
            text-align: center;
            padding: 60px 20px;
            color: #4ecdc4;
            font-size: 1.1rem;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(78, 205, 196, 0.3);
            border-top: 3px solid #4ecdc4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .stats-summary {
            background: rgba(255, 255, 255, 0.06);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            text-align: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
        }

        .stat-item {
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #4ecdc4;
            display: block;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #888;
            margin-top: 5px;
        }

        .settings-panel {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 25px;
            margin-bottom: 30px;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .settings-header h3 {
            margin: 0;
            color: #4ecdc4;
            font-size: 1.3rem;
        }

        .close-btn {
            background: rgba(255, 107, 107, 0.2);
            color: #ff6b6b;
            border: 1px solid rgba(255, 107, 107, 0.3);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            background: rgba(255, 107, 107, 0.3);
            transform: scale(1.1);
        }

        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 25px;
        }

        .setting-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .setting-group h4 {
            margin: 0 0 20px 0;
            color: #ffffff;
            font-size: 1.1rem;
        }

        .slider-container {
            margin-bottom: 15px;
        }

        .slider-container label {
            display: block;
            color: #b0b0b0;
            font-size: 0.9rem;
            margin-bottom: 8px;
        }

        .slider-container input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            margin-bottom: 5px;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            cursor: pointer;
            border: 2px solid #ffffff;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .slider-container input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            cursor: pointer;
            border: 2px solid #ffffff;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .slider-container span {
            display: inline-block;
            background: rgba(78, 205, 196, 0.2);
            color: #4ecdc4;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
            border: 1px solid rgba(78, 205, 196, 0.3);
        }

        .settings-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .apply-btn, .reset-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .apply-btn {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }

        .apply-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.4);
        }

        .reset-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .reset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        @media (max-width: 1024px) {
            .scanner-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .settings-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
        }

        @media (max-width: 768px) {
            .metrics-grid {
                grid-template-columns: 1fr;
            }
            
            .coin-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            
            .risk-timeframe {
                flex-direction: column;
                gap: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìä Daily Crypto Scanner</h1>
            <div class="subtitle">Smart Volume Analysis ‚Ä¢ Active vs Potential Opportunities</div>
            <div class="market-baseline" id="marketBaseline">
                üìà Market Baseline (ETH): Loading...
            </div>
        </div>

        <div class="controls">
            <button class="control-btn" onclick="runDailyScanner()">
                üîç Run Daily Scan
            </button>
            <button class="control-btn" onclick="refreshData()">
                üîÑ Refresh Data
            </button>
            <button class="control-btn" onclick="exportResults()">
                üìä Export Results
            </button>
            <button class="control-btn" onclick="toggleSettings()">
                ‚öôÔ∏è Settings
            </button>
        </div>

        <!-- Settings Panel -->
        <div class="settings-panel" id="settingsPanel" style="display: none;">
            <div class="settings-header">
                <h3>üéõÔ∏è Opportunity Detection Settings</h3>
                <button class="close-btn" onclick="toggleSettings()">‚úï</button>
            </div>
            
            <div class="settings-grid">
                <div class="setting-group">
                    <h4>üî• Active Opportunities</h4>
                    <div class="slider-container">
                        <label>Max Volume Diff vs ETH:</label>
                        <input type="range" id="activeVolumeThreshold" min="5" max="50" value="20" oninput="updateThresholdDisplay()">
                        <span id="activeVolumeValue">20%</span>
                    </div>
                    <div class="slider-container">
                        <label>Minimum Price Change:</label>
                        <input type="range" id="activePriceThreshold" min="1" max="15" value="5" oninput="updateThresholdDisplay()">
                        <span id="activePriceValue">5%</span>
                    </div>
                </div>

                <div class="setting-group">
                    <h4>üíé Potential Opportunities</h4>
                    <div class="slider-container">
                        <label>Max Volume Diff vs ETH:</label>
                        <input type="range" id="potentialVolumeThreshold" min="1" max="30" value="10" oninput="updateThresholdDisplay()">
                        <span id="potentialVolumeValue">30%</span>
                    </div>
                    <div class="slider-container">
                        
<label>Maximum Price Change:</label>
</div>
<div class="slider-container">
    <label>Start Rank:</label>
    <input type="number" id="startRank" min="1" max="300" value="1">
</div>
<div class="slider-container">
    <label>End Rank:</label>
    <input type="number" id="endRank" min="1" max="300" value="50">
</div>
<div class="slider-container">

                        <input type="range" id="potentialPriceThreshold" min="0" max="10" value="3" oninput="updateThresholdDisplay()">
                        <span id="potentialPriceValue">3%</span>
                    </div>
                </div>
            </div>

            <div class="settings-actions">
                <button class="apply-btn" onclick="applySettings()">Apply & Re-scan</button>
                <button class="reset-btn" onclick="resetSettings()">Reset Defaults</button>
            </div>
        </div>

        <div class="stats-summary" id="statsSummary" style="display: none;">
            <div class="stats-grid">
                <div class="stat-item">
                    <span class="stat-value" id="totalScanned">-</span>
                    <div class="stat-label">Coins Scanned</div>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="activeFound">-</span>
                    <div class="stat-label">Active Found</div>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="potentialFound">-</span>
                    <div class="stat-label">Potential Found</div>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="ethVolume">-</span>
                    <div class="stat-label">ETH Volume Change</div>
                </div>
            </div>
        </div>

        <div class="scanner-grid">
            <!-- Active Opportunities List -->
            <div class="opportunity-list">
                <div class="list-header active-header">
                    üî• ACTIVE OPPORTUNITIES
                    <div class="list-count" id="activeCount">0</div>
                </div>
                <div id="activeList">
                    <div class="loading">
                        <div class="loading-spinner"></div>
                        Click "Run Daily Scan" to analyze opportunities
                    </div>
                </div>
            </div>

            <!-- Potential Opportunities List -->
            <div class="opportunity-list">
                <div class="list-header potential-header">
                    üíé POTENTIAL OPPORTUNITIES
                    <div class="list-count" id="potentialCount">0</div>
                </div>
                <div id="potentialList">
                    <div class="loading">
                        <div class="loading-spinner"></div>
                        Click "Run Daily Scan" to analyze opportunities
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Mock data generator for development
        const MOCK_COINS = [
            { id: 'avalanche-2', name: 'Avalanche', symbol: 'AVAX', marketCap: 15000000000 },
            { id: 'polygon', name: 'Polygon', symbol: 'MATIC', marketCap: 9000000000 },
            { id: 'chainlink', name: 'Chainlink', symbol: 'LINK', marketCap: 8000000000 },
            { id: 'solana', name: 'Solana', symbol: 'SOL', marketCap: 45000000000 },
            { id: 'cardano', name: 'Cardano', symbol: 'ADA', marketCap: 12000000000 },
            { id: 'polkadot', name: 'Polkadot', symbol: 'DOT', marketCap: 7000000000 },
            { id: 'algorand', name: 'Algorand', symbol: 'ALGO', marketCap: 2000000000 },
            { id: 'near', name: 'NEAR Protocol', symbol: 'NEAR', marketCap: 3000000000 },
            { id: 'fantom', name: 'Fantom', symbol: 'FTM', marketCap: 1500000000 },
            { id: 'cosmos', name: 'Cosmos', symbol: 'ATOM', marketCap: 4000000000 }
        ];

        let scanResults = {
            activeList: [],
            potentialList: [],
            ethBaseline: { volumeChange: 0, priceChange: 0 },
            totalScanned: 0,
            timestamp: null
        };

        // Settings for opportunity detection
        let opportunitySettings = {
    startRank: 1,
    endRank: 50,
            activeVolumeThreshold: 20,
            activePriceThreshold: 5,
            potentialVolumeThreshold: 10,
            potentialPriceThreshold: 3
        };

        // Settings panel functions
        function toggleSettings() {
            const panel = document.getElementById('settingsPanel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                updateThresholdDisplay();
            } else {
                panel.style.display = 'none';
            }
        }

        function updateThresholdDisplay() {
            document.getElementById('activeVolumeValue').textContent = document.getElementById('activeVolumeThreshold').value + '%';
            document.getElementById('activePriceValue').textContent = document.getElementById('activePriceThreshold').value + '%';
            document.getElementById('potentialVolumeValue').textContent = document.getElementById('potentialVolumeThreshold').value + '%';
            document.getElementById('potentialPriceValue').textContent = document.getElementById('potentialPriceThreshold').value + '%';
        }

        
function applySettings() {
    const start = parseInt(document.getElementById('startRank').value);
    const end = parseInt(document.getElementById('endRank').value);

    if (isNaN(start) || isNaN(end) || start < 1 || end < 1) {
        alert('Start and End rank must be positive numbers.');
        return;
    }
    if (end < start) {
        alert('End Rank must be greater than or equal to Start Rank.');
        return;
    }

    opportunitySettings.activeVolumeThreshold = parseInt(document.getElementById('activeVolumeThreshold').value);
    opportunitySettings.activePriceThreshold = parseInt(document.getElementById('activePriceThreshold').value);
    opportunitySettings.potentialVolumeThreshold = parseInt(document.getElementById('potentialVolumeThreshold').value);
    opportunitySettings.potentialPriceThreshold = parseInt(document.getElementById('potentialPriceThreshold').value);
    opportunitySettings.startRank = start;
    opportunitySettings.endRank = end;

    console.log('üéõÔ∏è Updated Settings:', opportunitySettings);

    toggleSettings();
    runDailyScanner();
}


        function resetSettings() {
            // Reset to defaults
            opportunitySettings = {
                activeVolumeThreshold: 20,
                activePriceThreshold: 5,
                potentialVolumeThreshold: 10,
                potentialPriceThreshold: 3
            };
            
            // Update sliders
            document.getElementById('activeVolumeThreshold').value = 20;
            document.getElementById('activePriceThreshold').value = 5;
            document.getElementById('potentialVolumeThreshold').value = 30;
            document.getElementById('potentialPriceThreshold').value = 3;
            
            updateThresholdDisplay();
            console.log('üéõÔ∏è Settings reset to defaults');
        }

        // Function to switch between real and mock data - MOVED TO TOP
        async function getRealTimeDataFixed() {
            console.log('üîç DEBUG: Starting getRealTimeDataFixed() - NEW FUNCTION');
            
            try {
                const realData = await fetchRealCryptoData();
                console.log('üîç DEBUG: fetchRealCryptoData returned:', realData ? 'DATA OBJECT' : 'NULL');
                
                if (realData) {
                    console.log('üîç DEBUG: realData exists, checking properties...');
                    console.log('üîç DEBUG: realData.coins exists:', !!realData.coins);
                    console.log('üîç DEBUG: realData.coins.length:', realData.coins ? realData.coins.length : 'N/A');
                    console.log('üîç DEBUG: realData.source:', realData.source || 'NO SOURCE');
                    
                    if (realData && realData.coins && realData.coins.length > 0) {
                        console.log(`üéâ SUCCESS: Using real data from ${realData.source || 'API'}`);
                        
                        console.log('üîç DEBUG: About to call processRealData...');
                        const processedData = processRealData(realData);
                        console.log('üîç DEBUG: processRealData completed');
                        
                        console.log('üîç DEBUG: processedData exists:', !!processedData);
                        console.log('üîç DEBUG: processedData.coins exists:', !!(processedData && processedData.coins));
                        console.log('üîç DEBUG: processedData.coins.length:', processedData && processedData.coins ? processedData.coins.length : 'N/A');
                        
                        // Check if we got valid processed data
                        if (processedData && processedData.coins && processedData.coins.length > 0) {
                            console.log(`‚úÖ REAL DATA SUCCESS: ${processedData.coins.length} coins processed`);
                            
                            const result = {
                                coins: processedData.coins,
                                ethBaseline: processedData.ethBaseline,
                                isRealData: true
                            };
                            
                            console.log('üîç DEBUG: About to return real data with isRealData:', result.isRealData);
                            console.log('üîç DEBUG: Final result object keys:', Object.keys(result));
                            return result;
                        } else {
                            console.log('‚ùå VALIDATION FAILED: No valid coins after processing');
                        }
                    } else {
                        console.log('‚ùå API DATA VALIDATION FAILED');
                        console.log('üîç DEBUG: realData truthiness:', !!realData);
                        console.log('üîç DEBUG: realData.coins truthiness:', !!(realData && realData.coins));
                        console.log('üîç DEBUG: coins length > 0:', realData && realData.coins && realData.coins.length > 0);
                    }
                } else {
                    console.log('‚ùå fetchRealCryptoData returned null');
                }
            } catch (error) {
                console.error('‚ùå EXCEPTION in getRealTimeDataFixed:', error);
                console.error('‚ùå Stack trace:', error.stack);
            }
            
            // Fallback to mock data
            console.log('üé≠ FALLBACK: Generating mock data in getRealTimeDataFixed');
            const mockResult = {
                ...generateMockDataSet(),
                isRealData: false
            };
            console.log('üîç DEBUG: About to return mock data with isRealData:', mockResult.isRealData);
            return mockResult;
        }

        // Generate mock market data
        function generateMockData(coin) {
            const baseVolumeChange = Math.random() * 100 - 20; // -20% to +80%
            const ethVolumeChange = scanResults.ethBaseline.volumeChange || (Math.random() * 20 - 5); // -5% to +15%
            const relativeVolume = baseVolumeChange - ethVolumeChange;
            
            // Generate price change based on volume (some correlation, some divergence)
            let priceChange;
            if (Math.random() > 0.3) { // 70% correlation
                priceChange = relativeVolume * (0.1 + Math.random() * 0.3) + (Math.random() * 4 - 2);
            } else { // 30% divergence
                priceChange = Math.random() * 6 - 1; // -1% to +5%
            }

            const basePrice = Math.random() * 100 + 1;
            const supportLevel = basePrice * (0.85 + Math.random() * 0.1); // 85-95% of current price
            const supportTests = Math.floor(Math.random() * 12) + 6; // 6-18 tests
            const supportFrequency = Math.round((supportTests / 18) * 100);

            return {
                coin: coin,
                volumeChange: baseVolumeChange,
                relativeVolume: relativeVolume,
                priceChange: priceChange,
                currentPrice: basePrice,
                volumeWeightedMedian: basePrice * (0.98 + Math.random() * 0.04),
                dailyAvgMedian: basePrice * (0.97 + Math.random() * 0.06),
                supportLevel: supportLevel,
                supportTests: supportTests,
                supportFrequency: supportFrequency,
                volume24h: Math.random() * 500000000 + 50000000 // $50M - $550M
            };
        }

        // Classify opportunities into Active vs Potential - USING ADJUSTABLE SETTINGS
        function classifyOpportunities(marketData, ethBaseline) {
            const active = [];
            const potential = [];

            console.log('üéõÔ∏è Using settings:', opportunitySettings);

            marketData.forEach(data => {
                const { relativeVolume, priceChange } = data;

                // ACTIVE: Volume > threshold vs ETH AND Price > threshold (adjustable)
                if (relativeVolume > opportunitySettings.activeVolumeThreshold && priceChange > opportunitySettings.activePriceThreshold) {
                    active.push({
                        ...data,
                        category: "ACTIVE",
                        signal: "Momentum Confirmed",
                        riskLevel: "Medium-High",
                        timeframe: "Short-term play",
                        score: calculateActiveScore(data)
                    });
                }

                // POTENTIAL: Volume is similar to ETH (0‚Äìthreshold %) AND Price < threshold
                if (relativeVolume >= 0 && relativeVolume <= opportunitySettings.potentialVolumeThreshold && priceChange < opportunitySettings.potentialPriceThreshold) {
                    potential.push({
                        ...data,
                        category: "POTENTIAL",
                        signal: "Accumulation Phase",
                        riskLevel: "Low-Medium", 
                        timeframe: "Patient entry",
                        score: calculatePotentialScore(data)
                    });
                }

            });

            console.log(`üìä Found ${active.length} active and ${potential.length} potential opportunities with current settings`);

            return {
                active: active.sort((a, b) => b.score - a.score).slice(0, 8),
                potential: potential.sort((a, b) => b.score - a.score).slice(0, 10)
            };
        }

        function calculateActiveScore(data) {
            const momentumScore = Math.min(data.priceChange * 2, 40); // Up to 40 points
            const volumeScore = Math.min(data.relativeVolume, 30); // Up to 30 points  
            const supportScore = data.supportFrequency * 0.3; // Up to 30 points
            return Math.round(momentumScore + volumeScore + supportScore);
        }

        function calculatePotentialScore(data) {
            const volumeScore = Math.min(data.relativeVolume * 0.8, 50); // Up to 50 points
            const accumulationScore = Math.max(5 - data.priceChange, 0) * 5; // Up to 25 points (lower price change = higher score)
            const supportScore = data.supportFrequency * 0.25; // Up to 25 points
            return Math.round(volumeScore + accumulationScore + supportScore);
        }

        // Main scanner function - USING NEW FUNCTION NAME
        async function runDailyScanner() {
            showLoading();
            console.log('üîç DEBUG: Starting runDailyScanner()');
            
            try {
                // Get real-time cryptocurrency data - CALLING NEW FUNCTION
                const realTimeData = await getRealTimeDataFixed();
                console.log('üîç DEBUG: getRealTimeDataFixed returned:', realTimeData ? 'DATA OBJECT' : 'NULL');
                console.log('üîç DEBUG: realTimeData.isRealData:', realTimeData ? realTimeData.isRealData : 'N/A');
                
                if (realTimeData && realTimeData.isRealData) {
                    // Use real data
                    console.log('üéâ MAIN: Using REAL cryptocurrency data');
                    scanResults.ethBaseline = realTimeData.ethBaseline;
                    scanResults.isRealData = true;
                    const marketData = realTimeData.coins;
                    
                    console.log('üîç DEBUG: marketData.length:', marketData ? marketData.length : 'N/A');
                    
                    // Classify opportunities
                    const opportunities = classifyOpportunities(marketData, scanResults.ethBaseline);
                    
                    scanResults.activeList = opportunities.active;
                    scanResults.potentialList = opportunities.potential;
                    scanResults.totalScanned = marketData.length;
                    scanResults.timestamp = new Date();
                } else {
                    // Fallback to mock data if API fails
                    console.log('üé≠ MAIN: Using MOCK data (real data unavailable)');
                    scanResults.isRealData = false;
                    await runMockDataScan();
                }

                // Update UI
                updateMarketBaseline();
                updateStatsSummary();
                renderOpportunityLists();
                
            } catch (error) {
                console.error('‚ùå Main scanner error:', error);
                showError('Failed to run daily scan. Please try again.');
            }
        }

        // Fallback function for when API is unavailable
        async function runMockDataScan() {
            console.log('üé≠ Generating mock cryptocurrency data...');
            
            // Simulate API delay
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Generate ETH baseline
            const ethVolumeChange = Math.random() * 25 - 5; // -5% to +20%
            const ethPriceChange = Math.random() * 8 - 2; // -2% to +6%
            
            scanResults.ethBaseline = {
                volumeChange: ethVolumeChange,
                priceChange: ethPriceChange
            };

            // Generate market data for all coins
            const marketData = MOCK_COINS.map(coin => generateMockData(coin));
            
            // Classify opportunities
            const opportunities = classifyOpportunities(marketData, scanResults.ethBaseline);
            
            scanResults.activeList = opportunities.active;
            scanResults.potentialList = opportunities.potential;
            scanResults.totalScanned = MOCK_COINS.length;
            scanResults.timestamp = new Date();
        }

        function showLoading() {
            document.getElementById('activeList').innerHTML = `
                <div class="loading">
                    <div class="loading-spinner"></div>
                    Fetching live cryptocurrency data...
                </div>
            `;
            document.getElementById('potentialList').innerHTML = `
                <div class="loading">
                    <div class="loading-spinner"></div>
                    Analyzing real-time market patterns...
                </div>
            `;
        }

        function updateMarketBaseline() {
            const baseline = scanResults.ethBaseline;
            const volumeColor = baseline.volumeChange > 0 ? '#4ecdc4' : '#ff6b6b';
            const priceColor = baseline.priceChange > 0 ? '#96ceb4' : '#ff6b6b';
            
            // Check if we're using real data or mock data
            const dataSource = scanResults.isRealData ? 'üì° LIVE DATA' : 'üé≠ MOCK DATA';
            
            document.getElementById('marketBaseline').innerHTML = `
                üìà Market Baseline (ETH): 
                <span style="color: ${volumeColor}">Volume ${baseline.volumeChange > 0 ? '+' : ''}${baseline.volumeChange.toFixed(1)}%</span>, 
                <span style="color: ${priceColor}">Price ${baseline.priceChange > 0 ? '+' : ''}${baseline.priceChange.toFixed(1)}%</span>
                <br><small style="color: #888; font-size: 0.8em;">${dataSource}</small>
            `;
        }

        function updateStatsSummary() {
            document.getElementById('statsSummary').style.display = 'block';
            document.getElementById('totalScanned').textContent = scanResults.totalScanned;
            document.getElementById('activeFound').textContent = scanResults.activeList.length;
            document.getElementById('potentialFound').textContent = scanResults.potentialList.length;
            document.getElementById('ethVolume').textContent = `${scanResults.ethBaseline.volumeChange > 0 ? '+' : ''}${scanResults.ethBaseline.volumeChange.toFixed(1)}%`;
        }

        function renderOpportunityLists() {
            renderActiveList();
            renderPotentialList();
            
            document.getElementById('activeCount').textContent = scanResults.activeList.length;
            document.getElementById('potentialCount').textContent = scanResults.potentialList.length;
        }

        function renderActiveList() {
            const container = document.getElementById('activeList');
            
            if (scanResults.activeList.length === 0) {
                container.innerHTML = `
                    <div class="loading">
                        üîç No active opportunities found
                        <br><small>Volume and price momentum not aligned</small>
                    </div>
                `;
                return;
            }

            let html = '';
            scanResults.activeList.forEach((item, index) => {
                html += `
                    <div class="opportunity-item">
                        <div class="coin-header">
                            <div>
                                <span class="coin-name">${index + 1}. ${item.coin.name}</span>
                                <span class="coin-symbol">${item.coin.symbol}</span>
                            </div>
                            <div class="signal-badge momentum-confirmed">${item.signal}</div>
                        </div>
                        
                        <div class="metrics-grid">
                            <div class="metric">
                                <span class="metric-label">üìà Volume:</span>
                                <span class="metric-value volume-positive">+${item.relativeVolume.toFixed(1)}% vs ETH</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">üí∞ Price:</span>
                                <span class="metric-value price-positive">+${item.priceChange.toFixed(1)}% (24h)</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">üéØ 4H Median:</span>
                                <span class="metric-value">$${item.volumeWeightedMedian.toFixed(3)}</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">üìä Daily Avg:</span>
                                <span class="metric-value">$${item.dailyAvgMedian.toFixed(3)}</span>
                            </div>
                        
                            <div class="metric">
                                <span class="metric-label">üí≤ Current:</span>
                                <span class="metric-value">$${item.currentPrice.toFixed(3)}</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">‚ÜîÔ∏è Vs¬†Median:</span>
                                <span class="metric-value">${((item.currentPrice - item.volumeWeightedMedian) / item.volumeWeightedMedian * 100).toFixed(1)}%</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">üí≤ Current:</span>
                                <span class="metric-value">$${item.currentPrice.toFixed(3)}</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">‚ÜîÔ∏è Vs¬†Median:</span>
                                <span class="metric-value">${((item.currentPrice - item.volumeWeightedMedian) / item.volumeWeightedMedian * 100).toFixed(1)}%</span>
                            </div></div>
                        
                        <div class="support-info">
                            üõ°Ô∏è Support: $${item.supportLevel.toFixed(3)} (${item.supportTests}/18 tests, ${item.supportFrequency}% frequency)
                        </div>
                        
                        <div class="risk-timeframe">
                            <span class="risk-level risk-medium-high">üéØ ${item.riskLevel}</span>
                            <span>‚ö° ${item.timeframe} | Score: ${item.score}/100</span>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function renderPotentialList() {
            const container = document.getElementById('potentialList');
            
            if (scanResults.potentialList.length === 0) {
                container.innerHTML = `
                    <div class="loading">
                        üíé No potential opportunities found
                        <br><small>No significant volume without price movement</small>
                    </div>
                `;
                return;
            }

            let html = '';
            scanResults.potentialList.forEach((item, index) => {
                html += `
                    <div class="opportunity-item">
                        <div class="coin-header">
                            <div>
                                <span class="coin-name">${index + 1}. ${item.coin.name}</span>
                                <span class="coin-symbol">${item.coin.symbol}</span>
                            </div>
                            <div class="signal-badge accumulation-phase">${item.signal}</div>
                        </div>
                        
                        <div class="metrics-grid">
                            <div class="metric">
                                <span class="metric-label">üìä Volume:</span>
                                <span class="metric-value volume-positive">+${item.relativeVolume.toFixed(1)}% vs ETH</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">üí∞ Price:</span>
                                <span class="metric-value price-neutral">+${item.priceChange.toFixed(1)}% (24h)</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">üéØ 4H Median:</span>
                                <span class="metric-value">$${item.volumeWeightedMedian.toFixed(3)}</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">üìä Daily Avg:</span>
                                <span class="metric-value">$${item.dailyAvgMedian.toFixed(3)}</span>
                            </div>
                        </div>
                        
                        <div class="support-info">
                            üõ°Ô∏è Support: $${item.supportLevel.toFixed(3)} (${item.supportTests}/18 tests, ${item.supportFrequency}% frequency)
                        </div>
                        
                        <div class="risk-timeframe">
                            <span class="risk-level risk-low-medium">üéØ ${item.riskLevel}</span>
                            <span>üîç ${item.timeframe} | Score: ${item.score}/100</span>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function refreshData() {
            runDailyScanner();
        }

        function exportResults() {
            if (!scanResults.timestamp) {
                alert('No scan results to export. Please run a scan first.');
                return;
            }

            const exportData = {
                scanDate: scanResults.timestamp.toISOString().split('T')[0],
                ethBaseline: scanResults.ethBaseline,
                activeOpportunities: scanResults.activeList.map(item => ({
                    rank: scanResults.activeList.indexOf(item) + 1,
                    name: `${item.coin.name} (${item.coin.symbol})`,
                    relativeVolume: `+${item.relativeVolume.toFixed(1)}%`,
                    priceChange: `+${item.priceChange.toFixed(1)}%`,
                    score: item.score,
                    signal: item.signal,
                    supportLevel: `$${item.supportLevel.toFixed(3)}`,
                    supportFrequency: `${item.supportFrequency}%`
                })),
                potentialOpportunities: scanResults.potentialList.map(item => ({
                    rank: scanResults.potentialList.indexOf(item) + 1,
                    name: `${item.coin.name} (${item.coin.symbol})`,
                    relativeVolume: `+${item.relativeVolume.toFixed(1)}%`,
                    priceChange: `+${item.priceChange.toFixed(1)}%`,
                    score: item.score,
                    signal: item.signal,
                    supportLevel: `$${item.supportLevel.toFixed(3)}`,
                    supportFrequency: `${item.supportFrequency}%`
                }))
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `crypto-scan-${exportData.scanDate}.json`;
            link.click();
            
            URL.revokeObjectURL(url);
        }

        function showError(message) {
            document.getElementById('activeList').innerHTML = `
                <div class="loading" style="color: #ff6b6b;">
                    ‚ö†Ô∏è ${message}
                </div>
            `;
            document.getElementById('potentialList').innerHTML = `
                <div class="loading" style="color: #ff6b6b;">
                    ‚ö†Ô∏è ${message}
                </div>
            `;
        }

        // Initialize the app
        
document.addEventListener('DOMContentLoaded', function() {
    console.log('Daily Crypto Scanner initialized ‚Äì waiting for user action');
    // No automatic scan; user will adjust settings then click 'Run Daily Scan'
});


        // Add keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.key === 'r' || e.key === 'R') {
                e.preventDefault();
                runDailyScanner();
            }
            if (e.key === 'e' || e.key === 'E') {
                e.preventDefault();
                exportResults();
            }
        });

        
// Enhanced multi-page API integration

// --- Helper: simple sleep (promise) ---
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// --- Fetch CoinGecko data with back‚Äëoff / paging ---
async function fetchRealCryptoData() {
    try {
        console.log('Fetching CoinGecko data with back‚Äëoff‚Ä¶');

        const totalToFetch = opportunitySettings.endRank;
        const perPage = 250; // CoinGecko max
        const totalPages = Math.ceil(totalToFetch / perPage);
        let allCoins = [];

        for (let page = 1; page <= totalPages; page++) {
            const fetchCount = (page < totalPages) ? perPage
                                                   : (totalToFetch - perPage * (page - 1));
            const url = `https://tight-dew-5105.trungduong23.workers.dev/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=${fetchCount}&page=${page}&sparkline=false&price_change_percentage=24h`;

            let retries = 0;
            while (true) {
                const response = await fetch(url, {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' },
                    mode: 'cors'
                });

                if (response.status !== 429) {
                    if (!response.ok) throw new Error('Coins API error: ' + response.status);
                    const pageCoins = await response.json();
                    allCoins = allCoins.concat(pageCoins);
                    break; // success
                }

                retries++;
                if (retries > 3) throw new Error('Too many 429 responses ‚Äì aborting');
                const waitMs = (retries + 1) * 2000; // 2s, 4s, 6s
                console.warn(`‚è≥ 429 hit (attempt ${retries}) ‚Äì waiting ${waitMs/1000}s`);
                await sleep(waitMs);
            }

            // polite pause before next page
            await sleep(1200);
        }

        console.log(`‚úÖ Retrieved ${allCoins.length} coins (requested up to rank ${totalToFetch})`);

        const ethResponse = await fetch('https://tight-dew-5105.trungduong23.workers.dev/api/v3/simple/price?ids=ethereum&vs_currencies=usd&include_24hr_change=true', {
            method: 'GET',
            headers: { 'Accept': 'application/json' },
            mode: 'cors'
        });
        if (!ethResponse.ok) throw new Error('ETH API error: ' + ethResponse.status);
        const ethData = await ethResponse.json();

        return {
            coins: allCoins,
            ethData: ethData
        };
    } catch (error) {
        console.error('‚ùå API fetch failed:', error.message);
        return null;
    }
}

// Enhanced API integration with CORS handling
        

        // Convert Coinlore API data to our format
        function convertCoinloreData(data) {
            console.log('üîÑ Converting Coinlore data to our format...');
            
            const coins = data.data?.slice(0, 50).map(coin => ({
                id: coin.symbol?.toLowerCase(),
                name: coin.name,
                symbol: coin.symbol,
                current_price: parseFloat(coin.price_usd),
                market_cap: parseFloat(coin.market_cap_usd),
                total_volume: parseFloat(coin.volume24),
                price_change_percentage_24h: parseFloat(coin.percent_change_24h),
                market_cap_rank: parseInt(coin.rank)
            })) || [];

            // Find ETH data
            const ethCoin = coins.find(coin => coin.symbol === 'ETH') || { price_change_percentage_24h: 0 };
            
            console.log(`üîÑ Converted ${coins.length} coins from Coinlore`);
            console.log('üîÑ Sample converted coin:', coins[0]);
            
            return {
                coins: coins,
                ethData: {
                    market_data: {
                        price_change_percentage_24h: ethCoin.price_change_percentage_24h
                    }
                }
            };
        }

        // Function to switch between real and mock data
        async function getRealTimeData() {
            const realData = await fetchRealCryptoData();
            
            if (realData) {
                return processRealData(realData);
            } else {
                // Fallback to mock data generation
                console.log('Using mock data as fallback');
                return generateMockDataSet();
            }
        }

        function processRealData(apiData) {
            // Handle both CoinGecko and Coinlore API formats
            let ethPriceChange, ethVolumeChange;
            
            if (apiData.ethData.ethereum) {
                // Simple price endpoint format
                ethPriceChange = apiData.ethData.ethereum.usd_24h_change || 0;
                ethVolumeChange = ethPriceChange; // Use price change as proxy
            } else if (apiData.ethData.market_data) {
                // Full market data format
                ethPriceChange = apiData.ethData.market_data.price_change_percentage_24h || 0;
                ethVolumeChange = apiData.ethData.market_data.total_volume_change_percentage_24h || ethPriceChange;
            } else {
                // Fallback
                ethPriceChange = 0;
                ethVolumeChange = 0;
            }
            
            console.log(`üìä ETH Baseline - Price: ${ethPriceChange.toFixed(2)}%, Volume: ${ethVolumeChange.toFixed(2)}%`);
            
            const processedCoins = apiData.coins
                .filter(coin => {
                    const hasValidData = coin.current_price > 0 &&
                                       (coin.total_volume > 1000000 || coin.market_cap > 10000000);
                    return hasValidData;
                })
                .map(coin => {
                    const priceChange = parseFloat(coin.price_change_percentage_24h) || 0;
                    const relativeVolume = priceChange - ethVolumeChange;
                    
                    return {
                        coin: {
                            id: coin.id || coin.symbol?.toLowerCase(),
                            name: coin.name,
                            symbol: coin.symbol?.toUpperCase(),
                            marketCap: coin.market_cap || 0
                        },
                        volumeChange: priceChange,
                        relativeVolume: relativeVolume,
                        priceChange: priceChange,
                        currentPrice: parseFloat(coin.current_price) || 0,
                        volumeWeightedMedian: parseFloat(coin.current_price) * (0.995 + Math.random() * 0.01),
                        dailyAvgMedian: parseFloat(coin.current_price) * (0.99 + Math.random() * 0.02),
                        supportLevel: parseFloat(coin.current_price) * (0.85 + Math.random() * 0.1),
                        supportTests: Math.floor(Math.random() * 12) + 6,
                        supportFrequency: Math.round((Math.floor(Math.random() * 12) + 6) / 18 * 100),
                        volume24h: parseFloat(coin.total_volume) || 0,
                        marketCapRank: coin.market_cap_rank || 999
                    };
                })
                .filter(coin => {
        const rank = coin.marketCapRank || 999;
        return rank >= opportunitySettings.startRank && rank <= opportunitySettings.endRank;
    }); // Limit to top 40 for performance

            console.log(`‚úÖ Processed ${processedCoins.length} coins for analysis`);
            
            // Log some examples for debugging
            if (processedCoins.length > 0) {
                console.log('üìà Sample processed coin:', {
                    name: processedCoins[0].coin.name,
                    price: processedCoins[0].currentPrice,
                    change: processedCoins[0].priceChange + '%',
                    relativeVol: processedCoins[0].relativeVolume + '%'
                });
                
                console.log('üîç VALIDATION: Real data processing successful');
            } else {
                console.log('‚ùå VALIDATION: No valid coins after processing');
            }

            // Return the processed data - removed success flag, just return valid data
            return {
                coins: processedCoins,
                ethBaseline: {
                    volumeChange: ethVolumeChange,
                    priceChange: ethPriceChange
                }
            };
        }

        function generateMockDataSet() {
            const ethVolumeChange = Math.random() * 25 - 5;
            const ethPriceChange = Math.random() * 8 - 2;
            
            return {
                coins: MOCK_COINS.map(coin => generateMockData(coin)),
                ethBaseline: {
                    volumeChange: ethVolumeChange,
                    priceChange: ethPriceChange
                }
            };
        }
    </script>
</body>
</html>